<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POMPOMゲーム</title>
     <style>
        body {
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #fffacd;
            width: 100%;
            margin: 0;            
            min-height: 100vh; /* 画面全体を使う */
             box-sizing: border-box;
             padding: 0; 
          

        }
    
    
    h1 {
        color: #8b4513;
        margin-bottom: 10px;
         font-size: 1.5rem; /* スマホで小さめに */
    }


　　.game-description {
    font-size: 0.85rem;
    color: #8b4513;
    margin-bottom: 10px;
    text-align: center;
}
.help-btn {
    display: inline-block;  /* ブロックレベル要素として扱う */
    width: 25px !important; /* important を追加して優先適用 */
    height: 25px !important;
    min-width: unset;      /* 他のボタンスタイルの影響を無効化 */
    max-width: 25px;       /* 最大幅も設定 */
    border-radius: 0;      /* 四角形に */
    background: #8b4513;
    color: white;
    border: none;
    cursor: pointer;
    font-size: 0.8rem;       /* フォントサイズも少し大きく */
    vertical-align: middle;
    margin-left: 5px;
    padding: 0;
    line-height: 25px;      /* 行の高さも合わせて調整 */
    box-sizing: border-box; /* ボックスサイズの計算方法を明示 */
}
    .game-info {
        margin-bottom: 5px;
        font-size: 0.9rem;/* スマホで小さめ、約14px */
        display: flex;
        justify-content: space-between;
        width: 90vw;/* 画面幅の90%でスマホにフィット */
        max-width: 400px; /* PCでは400pxまで */
    }
    #score, #combo {
        font-weight: bold;
        color: #8b4513;
    }

    #status-message {
        margin: 10px 0;
        height: 20px;
        color: #d32f2f;
        font-weight: bold;
        font-size: 0.9rem; /* →→→ スマホで読みやすく →→→ */
    }
    #game-board {
        display: grid;
        grid-template-columns: repeat(6, 50px); 
        grid-template-rows: repeat(6, 50px);
        gap: 2px;
        background-color: #d2b48c;/* ゲームボードの背景色 */
        padding: 10px;
        border-radius: 10px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        box-sizing: content-box; /* パディングがグリッドに影響しない */
        max-width: 420px; 
    }
    .jewel {
        width: 50px;
        height:50px;
        border-radius: 8px;
        display: flex;
        justify-content: center;
        align-items: center;
        
        cursor: pointer;
        user-select: none;
        transition: all 0.3s;
        margin: 0; /* 宝石のマージンゼロ */
        box-sizing: border-box; /* サイズ厳密 */
        overflow: hidden; /* 画像はみ出し防止 */
        background-color: transparent; /* 透過背景 */
        font-size: 0;            
     }

     .jewel img {
        width: 100%; /* →→→ 50px→100%で縮小 →→→ */
        height: 100%;
        object-fit: contain;
        display: block; /* →→→ 追加：絵文字抑制 →→→ */

    }
     .jewel img[alt] {
        font-size: 0; /* →→→ 追加：altテキスト非表示 →→→ */
}
     .selected {
        transform: scale(0.8);
        box-shadow: 0 0 8px 4px gold;/* →→→ 復元：既存、入れ子削除 →→→ */
    }

     .falling {
    animation: fallAnimation 0.5s ease-in; /* →→→ 復元：既存、入れ子削除 →→→ */
    }
      @keyframes fallAnimation {
        0% {
            transform: translateY(-50px);
            opacity: 0.5;
        }
        100% {
            transform: translateY(0);
            opacity: 1;
        }
    }
    .buttons {
        margin-top: 15px;
        display: flex;
        gap: 10px;
        justify-content: center;
        width: 90vw;
        max-width: 400px;
      }
    
    button {
        padding: 8px 16px;
        font-size: 0.9rem;
        background-color: #8b4513;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        min-width: 120px; /* →→→ 追加：タッチしやすく →→→ */
    }
    button:hover {
        background-color: #8e24aa;
    }
    .jewel-shimmer {
        animation: shimmer 1.5s infinite;
    }
    @keyframes shimmer {
        0% {
            box-shadow: 0 0 3px 1px white;
        }
        50% {
            box-shadow: 0 0 8px 3px gold;
        }
        100% {
            box-shadow: 0 0 3px 1px white;
        }
    }
 /* →→→ ここに.credit追加！既存の{}は消さない！ →→→ */
.credit {
    margin-top: 10px;
    font-size: 0.8rem; 
    color: #8b4513;
    text-align: center;
    width: 90vw;
    max-width: 400px;
}
/* →→→ 追加終わり →→→ */

 @media screen and (max-width: 600px) {


           body {
           padding: 10px 0;
       }
            #game-board {
            gap: 1vw;
            grid-template-columns: repeat(6, 14vw);
            grid-template-rows: repeat(6, 14vw);
            padding: 2vw;
            max-width: 92vw;
        }

        .jewel {
            width: 14vw; /* →→→ 追加：スマホ対応 →→→ */
            height: 14vw;
            border-radius: 1.5vw; /* →→→ 追加：スマホで丸み調整 →→→ */
        }

          h1 {
              font-size: 1.3rem; /* タイトルサイズ調整 */
         }
        .buttons {
            margin-top: 3vw;
            gap: 2vw;
        }
        button {
            padding: 2vw 4vw;
            min-width: 30vw;
        }
        .credit {
            margin-top: 3vw;
        } /* →→→ 既存：スマホOK →→→ */
    }</style></head>
<body>
    <h1>POMPOM合わせゲーム</h1>
<!-- 追加するHTML -->
<div class="game-description">
    同じキャラを3つ以上、縦・横・斜めに並べよう！
    <button id="help-button" class="help-btn">?</button>
</div>

    <div class="game-info">
        <div>スコア: <span id="score">0</span></div>
        <div>連鎖: <span id="combo">0</span>倍</div>
    </div>
    <div id="status-message"></div>
    <div id="game-board">
      

</div>
<div class="buttons">
    <button id="restart-button">ゲームをリセット</button>
    <button id="hint-button">ヒントを表示</button>
</div>

<div class="credit">Sound: kirakira.mp3 by Make a field Music (Dova-syndrome)</div> <!-- →→→ 修正：作曲者統一 →→→ -->

<script>
    document.addEventListener('DOMContentLoaded', () =>{
        const board = document.getElementById('game-board');
        const scoreElement = document.getElementById('score');
        const comboElement = document.getElementById('combo');
        const statusMessage = document.getElementById('status-message');
        const restartButton = document.getElementById('restart-button');
        const hintButton = document.getElementById('hint-button');

     // モバイル対応強化 - スワイプ防止 - イベントリスナーは一度だけ設定
         document.body.addEventListener('touchmove', function(e) {
               if (isProcessing) {
                     e.preventDefault();
       }
       }, { passive: false });


        
// ★音再生関数の改善
function playMatchSound() {
    const sound = new Audio('sounds/kirakira.mp3');
    sound.volume = 0.3; // 音量30%
    
    sound.onerror = () => {
        console.log('音声ファイルが見つかりません');
    };
    
    // Promise APIを使用した音声再生
    sound.play().catch(e => {
        console.log('音再生エラー:', e);
        // ユーザーとのインタラクションがない場合の自動再生ポリシーでエラーになる場合が多い
    });
}

        // ゲーム設定
        const boardSize = 6;
        const jewelTypes = ['pom.png', 'pen.png', 'egg.png', 'pompom.png', 'palco.png', 'prin.png','kojyake.png'];
        let score = 0;
        let comboMultiplier = 1;
        let comboChain = 0;
        let selectedJewel = null;
        let gameBoard = [];
        let isProcessing = false;
        let hintTimeout = null;
        
        // 盤面初期化
        function initializeBoard() {
            isProcessing = true;
            board.innerHTML = ''; // combo-notification削除、完全リセット
            board.style.display = 'grid'; // グリッド強制
            gameBoard = [];
            score = 0;
            comboMultiplier = 1;
            comboChain = 0;
            scoreElement.textContent = score;
            comboElement.textContent = '1'; // 初期表示を「1」に
            statusMessage.textContent = '';
            clearTimeout(hintTimeout);
             selectedJewel = null; 

            // 盤面作成
            for (let row = 0; row < boardSize; row++) {
                gameBoard[row] = [];
                for (let col = 0; col < boardSize; col++) {
                    // 最初からマッチングができないようにする
                    let jewelType;
                    do {
                        jewelType = getRandomJewel();
                    } while (
                        (row >= 2 && gameBoard[row-1][col] === jewelType && gameBoard[row-2][col] === jewelType) ||
                        (col >= 2 && gameBoard[row][col-1] === jewelType && gameBoard[row][col-2] === jewelType)
                    );
                    
                    gameBoard[row][col] = jewelType;
                   createJewelElement(row, col, jewelType); // ★jewelを代入！

                }
            }
            
            // 初期盤面で可能な手があるか確認
            setTimeout(() => {
                if (!findPossibleMove()) {
                    shuffleBoard();
                }
               
              // 追加するコード:
// モバイル対応強化 - スワイプ防止 
document.body.addEventListener('touchmove', function(e) {
    if (isProcessing) {
        e.preventDefault();
    }
}, { passive: false });


 isProcessing = false;

            }, 500);
        }
        
        // ランダムな宝石を取得
        function getRandomJewel() {
            return jewelTypes[Math.floor(Math.random() * jewelTypes.length)];
        }
        
        // 宝石要素の作成
        function createJewelElement(row, col, jewelType) {
            const jewel = document.createElement('div');
            jewel.className = 'jewel';
            jewel.style.backgroundColor = 'transparent'; // 背景透過
            jewel.dataset.row = row;
            jewel.dataset.col = col;
            jewel.style.gridRow = `${row + 1} / span 1`; // →→→ 修正：直接指定 →→→
            jewel.style.gridColumn = `${col + 1} / span 1`; // →→→ 修正：直接指定 →→→
            jewel.style.margin = '0';
      
           // 画像を追加
               const img = document.createElement('img');
              img.alt = jewelType.replace('.png', ''); // 代替テキスト設定
               img.style.objectFit = 'contain'; // 枠内に収める

           img.onerror = () => {
             // 画像ロード失敗時のフォールバック - レスポンシブ対応
            jewel.style.backgroundColor = '#f8d7da'; // エラー色
            jewel.style.color = '#721c24'; // テキスト色
            jewel.style.fontSize = 'min(16px, 4vw)'; // レスポンシブフォント
            jewel.style.display = 'flex';
            jewel.style.alignItems = 'center';
            jewel.style.justifyContent = 'center';
            jewel.style.borderRadius = '8px'; // 角丸を維持
            jewel.textContent = jewelType.replace('.png', '').charAt(0).toUpperCase(); // 先頭文字表示
            console.log(`画像読み込みエラー: ${jewelType}`);
         };
            console.log('img.src:', imagePath + jewelType);
            const imagePath = './images/';
            img.src = imagePath + jewelType;
            
            jewel.appendChild(img) 

              // クリックイベントリスナー       
                jewel.addEventListener('click', () => {
                if (!isProcessing) {
                    handleJewelClick(jewel, row, col);
                }
            });


 // →→→ ここにタッチイベント入れる！ →→→
    jewel.addEventListener('touchstart', (e) => {
        e.preventDefault(); // スクロール防止
        if (!isProcessing) {
            handleJewelClick(jewel, row, col);
        }
    });
    // →→→ タッチイベント終わり →→→

            board.appendChild(jewel);
            return jewel;
        }

        
        // 宝石クリックの処理
        function handleJewelClick(jewel, row, col) {
            clearJewelShimmer();
            
            if (selectedJewel === null) {
                // 最初の宝石を選択
                selectedJewel = {
                    element: jewel,
                    row: row,
                    col: col
                };
                jewel.classList.add('selected');
            } else {
                // 2番目の宝石を選択
                const firstRow = selectedJewel.row;
                const firstCol = selectedJewel.col;
                
                // 選択解除
                selectedJewel.element.classList.remove('selected');
                
                // 隣接しているかチェック（斜め方向も含む）
                if (isAdjacentIncludingDiagonal(firstRow, firstCol, row, col)) {
                    isProcessing = true;
                    statusMessage.textContent = '';
                    
                    // 宝石を交換
                    swapJewels(firstRow, firstCol, row, col);
                    
                    // マッチがあるかチェック
                    setTimeout(() => {
                        let matchFound = checkAndRemoveMatches();
                        if (!matchFound) {
                            // マッチがなければ元に戻す
                            swapJewels(row, col, firstRow, firstCol);
                            isProcessing = false;
                        } else {
                            // コンボ開始
                            comboChain = 1;
                            comboMultiplier = 1;
                            comboElement.textContent = comboMultiplier;
                            
                            // スコア更新（基本点）
                            updateScore(10);
                            
                            // 空きスペースを埋める
                            setTimeout(() => fillEmptySpaces(), 300);
                        }
                    }, 300);
                }
                
                selectedJewel = null;
            }
        }
        
        // 隣接しているかチェック（斜め方向も含む）
        function isAdjacentIncludingDiagonal(row1, col1, row2, col2) {
            const rowDiff = Math.abs(row1 - row2);
            const colDiff = Math.abs(col1 - col2);
            
            // 上下左右または斜めに隣接している場合
            return (rowDiff <= 1 && colDiff <= 1 && !(rowDiff === 0 && colDiff === 0));
        }
        
        // 宝石を交換
        function swapJewels(row1, col1, row2, col2) {
            // ゲームボード上でのデータ交換
            const temp = gameBoard[row1][col1];
            gameBoard[row1][col1] = gameBoard[row2][col2];
            gameBoard[row2][col2] = temp;
            
            // 画面表示の更新
            updateBoardDisplay();
        }
        
        // 盤面表示の更新
        function updateBoardDisplay() {
            const jewels = document.querySelectorAll('.jewel');
            jewels.forEach(jewel => {
                const row = parseInt(jewel.dataset.row);
                const col = parseInt(jewel.dataset.col);
                const img = jewel.querySelector('img');
                img.src = gameBoard[row][col]; // 画像パス（shiyun1.pngなど）
            });
        }
        
  // マッチをチェックして削除
        function checkAndRemoveMatches() {
            let matchFound = false;
            
            // マッチした宝石を記録する配列
            let matchedJewels = Array(boardSize).fill().map(() => Array(boardSize).fill(false));
            
            // 水平方向のマッチをチェック
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize - 2; col++) {
                    const currentType = gameBoard[row][col];
                    if (currentType && 
                        currentType === gameBoard[row][col + 1] && 
                        currentType === gameBoard[row][col + 2]) {
                        
                        // マッチした宝石をマーク
                        let matchLength = 3;
                        while (col + matchLength < boardSize && 
                               gameBoard[row][col + matchLength] === currentType) {
                            matchLength++;
                        }
                        
                        for (let i = 0; i < matchLength; i++) {
                            matchedJewels[row][col + i] = true;
                        }
                        
                        matchFound = true;
                    }
                }
            }
            
            // 垂直方向のマッチをチェック
            for (let col = 0; col < boardSize; col++) {
                for (let row = 0; row < boardSize - 2; row++) {
                    const currentType = gameBoard[row][col];
                    if (currentType && 
                        currentType === gameBoard[row + 1][col] && 
                        currentType === gameBoard[row + 2][col]) {
                        
                        // マッチした宝石をマーク
                        let matchLength = 3;
                        while (row + matchLength < boardSize && 
                               gameBoard[row + matchLength][col] === currentType) {
                            matchLength++;
                        }
                        
                        for (let i = 0; i < matchLength; i++) {
                            matchedJewels[row + i][col] = true;
                        }
                        
                        matchFound = true;
                    }
                }
            }
            
            // 斜め（右下方向）のマッチをチェック
            for (let row = 0; row < boardSize - 2; row++) {
                for (let col = 0; col < boardSize - 2; col++) {
                    const currentType = gameBoard[row][col];
                    if (currentType && 
                        currentType === gameBoard[row + 1][col + 1] && 
                        currentType === gameBoard[row + 2][col + 2]) {
                        
                        // マッチした宝石をマーク
                        let matchLength = 3;
                        while (row + matchLength < boardSize && 
                               col + matchLength < boardSize && 
                               gameBoard[row + matchLength][col + matchLength] === currentType) {
                            matchLength++;
                        }
                        
                        for (let i = 0; i < matchLength; i++) {
                            matchedJewels[row + i][col + i] = true;
                        }
                        
                        matchFound = true;
                    }
                }
            }
            
            // 斜め（左下方向）のマッチをチェック
            for (let row = 0; row < boardSize - 2; row++) {
                for (let col = 2; col < boardSize; col++) {
                    const currentType = gameBoard[row][col];
                    if (currentType && 
                        currentType === gameBoard[row + 1][col - 1] && 
                        currentType === gameBoard[row + 2][col - 2]) {
                        
                        // マッチした宝石をマーク
                        let matchLength = 3;
                        while (row + matchLength < boardSize && 
                               col - matchLength >= 0 && 
                               gameBoard[row + matchLength][col - matchLength] === currentType) {
                            matchLength++;
                        }
                        
                        for (let i = 0; i < matchLength; i++) {
                            matchedJewels[row + i][col - i] = true;
                        }
                        
                        matchFound = true;
                    }
                }
            }
            
            // マッチした宝石の数をカウント
            let matchCount = 0;
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    if (matchedJewels[row][col]) {
                        matchCount++;
                    }
                }
            }
            
            // マッチした宝石を削除
            if (matchFound) {
         
            // ★音を鳴らす
               playMatchSound();
                  console.log('初回マッチ音再生！');
                for (let row = 0; row < boardSize; row++) {
                    for (let col = 0; col < boardSize; col++) {
                        if (matchedJewels[row][col]) {
                            gameBoard[row][col] = null;
                        }
                    }
                }
                
                // 削除した宝石の表示を更新
                const jewels = document.querySelectorAll('.jewel');
                jewels.forEach(jewel => {
                    const row = parseInt(jewel.dataset.row);
                    const col = parseInt(jewel.dataset.col);
                    if (gameBoard[row][col] === null) {
                      jewel.style.opacity = '0';
                    }
                });
            }
            
            return matchFound;
        }
        
function updateComboDisplay() {
 if (comboMultiplier > 1) {
        // アニメーション効果と表示を一元化
        comboElement.textContent = `${comboMultiplier}倍`;
        comboElement.style.transition = 'transform 0.2s ease-in-out';
        comboElement.style.transform = 'scale(1.2)';
        
        setTimeout(() => {
            comboElement.style.transform = 'scale(1)';
        }, 200);
        
        // コンボが終了したら元に戻す処理は fillEmptySpaces 内で行う
        // ここではタイマーを設定しない
    } else {
        comboElement.textContent = `${comboMultiplier}倍`;
    }
}

 // スコア更新

   function updateScore(basePoints) {
    let points = basePoints * comboMultiplier;
    score += points;
    scoreElement.textContent = score;

// 点数アニメーション
    scoreElement.style.transition = 'transform 0.2s ease-in-out';
    scoreElement.style.transform = 'scale(1.2)';
    
    setTimeout(() => {
        scoreElement.style.transform = 'scale(1)';
    }, 200);
}
    
   

            // 空きスペースを埋める
       
function fillEmptySpaces() {
    let needsRefill = false;
    
    // 各列で空きスペースを下に詰める
    for (let col = 0; col < boardSize; col++) {
        let emptySpaces = 0;
        
        // 下から上に見ていき、空きスペースをカウント
        for (let row = boardSize - 1; row >= 0; row--) {
            if (gameBoard[row][col] === null) {
                emptySpaces++;
            } else if (emptySpaces > 0) {
                // 空きスペースがあれば、下に移動
                gameBoard[row + emptySpaces][col] = gameBoard[row][col];
                gameBoard[row][col] = null;
                needsRefill = true;
            }
        }
        
        // 上部の空きスペースに新しい宝石を生成
        for (let row = 0; row < boardSize; row++) {
            if (gameBoard[row][col] === null) {
                gameBoard[row][col] = getRandomJewel();
                needsRefill = true;
            }
        }
    }
    
    // 盤面を再描画
    renderBoard();
    
    // デバッグ用
    if (needsRefill) {
        console.log('盤面を埋めました');
    }
    
    // 新しいマッチをチェック
    setTimeout(() => {
        let matchFound = checkAndRemoveMatches();
        
        console.log('連鎖マッチ:', matchFound);
        
        if (matchFound) {
            // 連鎖音
            playMatchSound();
            console.log('連鎖音再生！');
            
            // コンボ継続
            comboChain++;
            
            // コンボ倍率更新（最大5倍まで）
            comboMultiplier = Math.min(comboChain, 5);
            
            // コンボ表示
            updateComboDisplay();
            
            // 連鎖ボーナス
            updateScore(5 * comboChain);
            
            setTimeout(() => fillEmptySpaces(), 300);
        } else {
            // 連続マッチの制限 - 無限ループ防止
            if (comboChain > 15) {
                statusMessage.textContent = "すごい連鎖！新しい盤面にリセットします！";
                setTimeout(() => {
                    initializeBoard();
                    return;
                }, 2000);
            } else {
                // コンボリセット
                comboChain = 0;
                comboMultiplier = 1;
                updateComboDisplay();
                
                // 手詰まりチェック
                if (!findPossibleMove()) {
                    statusMessage.textContent = "これ以上の手がありません！盤面を入れ替えます...";
                    setTimeout(() => {
                        shuffleBoard();
                    }, 1500);
                } else {
                    // 処理完了
                    isProcessing = false;
                }
            }
        }
    }, 500);
}
        
        // 盤面を再描画
        function renderBoard() {
            const existingJewels = {};
            const jewels = document.querySelectorAll('.jewel');
　　　　　
            jewels.forEach(jewel => {
        const row = parseInt(jewel.dataset.row);
        const col = parseInt(jewel.dataset.col);
        const key = `${row}-${col}`;
        existingJewels[key] = jewel;
    });

   // 盤面をクリア
    board.innerHTML = '';

 // グリッドを強制リセット
    board.style.display = 'grid';

// 一旦すべての宝石を配置
               for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                 const key = `${row}-${col}`;
                  let jewel;


 // 既存の宝石を再利用するか、新しい宝石を作成
            if (existingJewels[key] && gameBoard[row][col] !== null) {
                jewel = existingJewels[key];
                const img = jewel.querySelector('img');
                if (img) {
                    img.src = gameBoard[row][col];
                }
　　　　　   } else {
                     jewel = createJewelElement(row, col, gameBoard[row][col]);
            }
            
// スタイルをリセット
            jewel.style.opacity = '1';
            jewel.style.transform = 'scale(1)';
            jewel.style.margin = '0';
            
            // 盤面に追加
            board.appendChild(jewel);
        }
    }

     
          // アニメーション用のクラスを少し遅れて追加（レンダリング後）
             setTimeout(() => {
              const jewels = document.querySelectorAll('.jewel');
               jewels.forEach(jewel => {
                 const row = parseInt(jewel.dataset.row);
                   if (row < boardSize / 2) {
                    jewel.classList.add('falling');
      　　　　　 }
       　　});
   　　　 }, 50);
　　}

        
        // 可能な手を探す
        function findPossibleMove() {
            // 全ての隣接ペアをチェック
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    // 上下左右と斜めの8方向をチェック
                    const directions = [
                        [-1, 0], [1, 0], [0, -1], [0, 1], // 上下左右
                        [-1, -1], [-1, 1], [1, -1], [1, 1] // 斜め
                    ];
                    
                    for (const [dx, dy] of directions) {
                        const newRow = row + dx;
                        const newCol = col + dy;
                        
                        // 盤面内かチェック
                        if (newRow >= 0 && newRow < boardSize && newCol >= 0 && newCol < boardSize) {
                            // 宝石を仮に入れ替える
                            const temp = gameBoard[row][col];
                            gameBoard[row][col] = gameBoard[newRow][newCol];
                            gameBoard[newRow][newCol] = temp;
                            
                            // マッチするかチェック
                            let hasMatch = checkForMatches();
                            
                            // 元に戻す
                            gameBoard[newRow][newCol] = gameBoard[row][col];
                            gameBoard[row][col] = temp;
                            
                            if (hasMatch) {
                                return { row, col, newRow, newCol };
                            }
                        }
                    }
                }
            }
            
            return false;
        }
        
        // マッチがあるかチェック（削除はしない）
        function checkForMatches() {
            // 水平方向
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize - 2; col++) {
                    const current = gameBoard[row][col];
                    if (current && 
                        current === gameBoard[row][col + 1] && 
                        current === gameBoard[row][col + 2]) {
                        return true;
                    }
                }
            }
            
            // 垂直方向
            for (let col = 0; col < boardSize; col++) {
                for (let row = 0; row < boardSize - 2; row++) {
                    const current = gameBoard[row][col];
                    if (current && 
                        current === gameBoard[row + 1][col] && 
                        current === gameBoard[row + 2][col]) {
                        return true;
                    }
                }
            }
            
            // 斜め（右下）
            for (let row = 0; row < boardSize - 2; row++) {
                for (let col = 0; col < boardSize - 2; col++) {
                    const current = gameBoard[row][col];
                    if (current &&
                        current === gameBoard[row + 1][col + 1] &&
                        current === gameBoard[row + 2][col + 2]) {
                        return true;
                    }
                }
            }
            
            // 斜め（左下）
            for (let row = 0; row < boardSize - 2; row++) {
                for (let col = 2; col < boardSize; col++) {
                    const current = gameBoard[row][col];
                    if (current &&
                        current === gameBoard[row + 1][col - 1] &&
                        current === gameBoard[row + 2][col - 2]) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // 盤面をシャッフル
        function shuffleBoard() {
            isProcessing = true;
            
            // 全ての宝石を配列に集める
            let allJewels = [];
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    allJewels.push(gameBoard[row][col]);
                }
            }
            
            // シャッフル
            for (let i = allJewels.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allJewels[i], allJewels[j]] = [allJewels[j], allJewels[i]];
            }
            
            // 盤面に戻す
            let index = 0;
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    gameBoard[row][col] = allJewels[index++];
                }
            }
            
            // シャッフル後に手があるか確認
            if (!findPossibleMove()) {
                // もう一度シャッフル
                shuffleBoard();
                return;
            }
            
            // 盤面更新
            updateBoardDisplay();
            statusMessage.textContent = "盤面を入れ替えました！";

           // シャッフルのビジュアルフィードバック
                const jewels = document.querySelectorAll('.jewel');
               jewels.forEach(jewel => {
               jewel.style.transition = 'transform 0.3s ease-in-out';
               jewel.style.transform = 'scale(0.8)';
                setTimeout(() => {
        　　　　jewel.style.transform = 'scale(1)';
    　　　　　　　　　　　　　　　　}, 300);
　　　　　　　　　　　});

            
            // 少しの間待機
            setTimeout(() => {
                statusMessage.textContent = "";
                isProcessing = false;
            }, 1000);
        }
        
        // ヒントを表示
        function showHint() {
            if (isProcessing) return;
            
            clearJewelShimmer();
            
            const move = findPossibleMove();
            if (move) {
                const { row, col, newRow, newCol } = move;
                
                // ヒントの宝石を光らせる
                const jewels = document.querySelectorAll('.jewel');
                jewels.forEach(jewel => {
                    const r = parseInt(jewel.dataset.row);
                    const c = parseInt(jewel.dataset.col);
                    if ((r === row && c === col) || (r === newRow && c === newCol)) {
                        jewel.classList.add('jewel-shimmer');
                    }
                });
                
                // 10秒後にヒントを消す
                hintTimeout = setTimeout(clearJewelShimmer, 10000);
            }
        }
        
        // ヒントの光を消す
        function clearJewelShimmer() {
            clearTimeout(hintTimeout);
            const shimmering = document.querySelectorAll('.jewel-shimmer');
            shimmering.forEach(jewel => {
                jewel.classList.remove('jewel-shimmer');
            });
        }
        
        // リスタートボタン
        restartButton.addEventListener('click', initializeBoard);
        
        // ヒントボタン
        hintButton.addEventListener('click', showHint);
// 追加するコード:
// ヘルプボタン
const helpButton = document.getElementById('help-button');
helpButton.addEventListener('click', () => {
    // ヘルプ表示
    alert('【ゲームの遊び方】\n\n1. 隣接する宝石をクリック/タップして交換します\n2. 同じ宝石を3つ以上縦・横・斜めに並べると消えます\n3. 連鎖するとコンボ倍率が上がります！\n\n困ったらヒントボタンを押してください');
});
        
        // ゲーム開始
        initializeBoard();
    });
</script>

<div class="game-link">
  <a href="index.html">
       <p>TOPへ戻る</p>
  </a>
</div>

</body>
</html>

